// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tokens.sql

package repo

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getAllTokensByScope = `-- name: GetAllTokensByScope :many
SELECT
    tokens.hash,
    tokens.user_id,
    tokens.scope,
    tokens.created_at,
    tokens.used_at,
    tokens.revoked_at,
    tokens.expires_at
FROM tokens
JOIN users
    ON users.id = tokens.user_id
WHERE users.email = $1
    AND tokens.scope = $2
    AND tokens.revoked_at IS NULL
    AND tokens.expires_at > NOW()
ORDER BY tokens.used_at DESC NULLS LAST
`

type GetAllTokensByScopeParams struct {
	Email string `json:"email"`
	Scope string `json:"scope"`
}

func (q *Queries) GetAllTokensByScope(ctx context.Context, arg GetAllTokensByScopeParams) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, getAllTokensByScope, arg.Email, arg.Scope)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.Hash,
			&i.UserID,
			&i.Scope,
			&i.CreatedAt,
			&i.UsedAt,
			&i.RevokedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllTokensByUserID = `-- name: GetAllTokensByUserID :many
SELECT hash, user_id, scope, created_at, used_at, revoked_at, expires_at
FROM tokens
WHERE user_id = $1
`

func (q *Queries) GetAllTokensByUserID(ctx context.Context, userID uuid.UUID) ([]Token, error) {
	rows, err := q.db.QueryContext(ctx, getAllTokensByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Token
	for rows.Next() {
		var i Token
		if err := rows.Scan(
			&i.Hash,
			&i.UserID,
			&i.Scope,
			&i.CreatedAt,
			&i.UsedAt,
			&i.RevokedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTokenByHash = `-- name: GetTokenByHash :one
SELECT hash, user_id, scope, created_at, used_at, revoked_at, expires_at
FROM tokens
WHERE hash = $1
`

func (q *Queries) GetTokenByHash(ctx context.Context, hash string) (Token, error) {
	row := q.db.QueryRowContext(ctx, getTokenByHash, hash)
	var i Token
	err := row.Scan(
		&i.Hash,
		&i.UserID,
		&i.Scope,
		&i.CreatedAt,
		&i.UsedAt,
		&i.RevokedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const insertToken = `-- name: InsertToken :exec
INSERT INTO tokens (hash, user_id, scope, expires_at)
VALUES( $1, $2, $3, $4)
`

type InsertTokenParams struct {
	Hash      string    `json:"hash"`
	UserID    uuid.UUID `json:"user_id"`
	Scope     string    `json:"scope"`
	ExpiresAt time.Time `json:"expires_at"`
}

func (q *Queries) InsertToken(ctx context.Context, arg InsertTokenParams) error {
	_, err := q.db.ExecContext(ctx, insertToken,
		arg.Hash,
		arg.UserID,
		arg.Scope,
		arg.ExpiresAt,
	)
	return err
}

const useToken = `-- name: UseToken :execrows
UPDATE tokens
SET used_at = CURRENT_TIMESTAMP
WHERE hash = $1
`

func (q *Queries) UseToken(ctx context.Context, hash string) (int64, error) {
	result, err := q.db.ExecContext(ctx, useToken, hash)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
