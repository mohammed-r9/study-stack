// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: materials.sql

package repo

import (
	"context"

	"github.com/google/uuid"
)

const archiveMaterial = `-- name: ArchiveMaterial :execrows
UPDATE materials
SET archived_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE materials.id = $1 
  AND materials.archived_at IS NULL
  AND EXISTS (
      SELECT 1 
      FROM collections 
      WHERE collections.id = materials.collection_id 
        AND collections.user_id = $2
  )
`

type ArchiveMaterialParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) ArchiveMaterial(ctx context.Context, arg ArchiveMaterialParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, archiveMaterial, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAllArchivedMaterialsInCollection = `-- name: GetAllArchivedMaterialsInCollection :many
SELECT 
    m.id, 
    m.collection_id, 
    m.title, 
    m.created_at, 
    m.updated_at, 
    m.archived_at
FROM materials m
JOIN collections c ON m.collection_id = c.id
WHERE c.user_id = $1 
  AND m.collection_id = $2
  AND m.archived_at IS NOT NULL
LIMIT 20
`

type GetAllArchivedMaterialsInCollectionParams struct {
	UserID       uuid.UUID `json:"user_id"`
	CollectionID uuid.UUID `json:"collection_id"`
}

func (q *Queries) GetAllArchivedMaterialsInCollection(ctx context.Context, arg GetAllArchivedMaterialsInCollectionParams) ([]Material, error) {
	rows, err := q.db.QueryContext(ctx, getAllArchivedMaterialsInCollection, arg.UserID, arg.CollectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Material
	for rows.Next() {
		var i Material
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMaterialsInCollection = `-- name: GetAllMaterialsInCollection :many
SELECT 
    m.id, 
    m.collection_id, 
    m.title, 
    m.created_at, 
    m.updated_at, 
    m.archived_at
FROM materials m
JOIN collections c ON m.collection_id = c.id
WHERE c.user_id = $1 
  AND m.collection_id = $2
LIMIT 20
`

type GetAllMaterialsInCollectionParams struct {
	UserID       uuid.UUID `json:"user_id"`
	CollectionID uuid.UUID `json:"collection_id"`
}

func (q *Queries) GetAllMaterialsInCollection(ctx context.Context, arg GetAllMaterialsInCollectionParams) ([]Material, error) {
	rows, err := q.db.QueryContext(ctx, getAllMaterialsInCollection, arg.UserID, arg.CollectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Material
	for rows.Next() {
		var i Material
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnarchivedMaterialsInCollection = `-- name: GetAllUnarchivedMaterialsInCollection :many
SELECT 
    m.id, 
    m.collection_id, 
    m.title, 
    m.created_at, 
    m.updated_at, 
    m.archived_at
FROM materials m
JOIN collections c ON m.collection_id = c.id
WHERE c.user_id = $1 
  AND m.collection_id = $2
  AND m.archived_at IS NULL
LIMIT 20
`

type GetAllUnarchivedMaterialsInCollectionParams struct {
	UserID       uuid.UUID `json:"user_id"`
	CollectionID uuid.UUID `json:"collection_id"`
}

func (q *Queries) GetAllUnarchivedMaterialsInCollection(ctx context.Context, arg GetAllUnarchivedMaterialsInCollectionParams) ([]Material, error) {
	rows, err := q.db.QueryContext(ctx, getAllUnarchivedMaterialsInCollection, arg.UserID, arg.CollectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Material
	for rows.Next() {
		var i Material
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaterialByID = `-- name: GetMaterialByID :one
SELECT 
    m.id, 
    m.collection_id, 
    m.title, 
    m.created_at, 
    m.updated_at, 
    m.archived_at
FROM materials m
JOIN collections c ON m.collection_id = c.id
WHERE m.id = $1 
  AND c.user_id = $2
  AND m.archived_at IS NULL
`

type GetMaterialByIDParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) GetMaterialByID(ctx context.Context, arg GetMaterialByIDParams) (Material, error) {
	row := q.db.QueryRowContext(ctx, getMaterialByID, arg.ID, arg.UserID)
	var i Material
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ArchivedAt,
	)
	return i, err
}

const insertMaterial = `-- name: InsertMaterial :exec
INSERT INTO materials (id, collection_id, title)
SELECT $1, $2, $3
WHERE (
    SELECT COUNT(*) 
    FROM materials 
    WHERE collection_id = $2
) < 20
AND EXISTS (
    SELECT 1 
    FROM collections 
    WHERE id = $2 AND user_id = $4
)
`

type InsertMaterialParams struct {
	ID           uuid.UUID `json:"id"`
	CollectionID uuid.UUID `json:"collection_id"`
	Title        string    `json:"title"`
	UserID       uuid.UUID `json:"user_id"`
}

func (q *Queries) InsertMaterial(ctx context.Context, arg InsertMaterialParams) error {
	_, err := q.db.ExecContext(ctx, insertMaterial,
		arg.ID,
		arg.CollectionID,
		arg.Title,
		arg.UserID,
	)
	return err
}

const unarchiveMaterial = `-- name: UnarchiveMaterial :execrows
UPDATE materials
SET archived_at = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE materials.id = $1 
  AND materials.archived_at IS NOT NULL
  AND EXISTS (
      SELECT 1 
      FROM collections 
      WHERE collections.id = materials.collection_id 
        AND collections.user_id = $2
  )
  AND (
      SELECT COUNT(*) 
      FROM materials 
      WHERE collection_id = materials.collection_id 
        AND archived_at IS NULL
  ) < 20
`

type UnarchiveMaterialParams struct {
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) UnarchiveMaterial(ctx context.Context, arg UnarchiveMaterialParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, unarchiveMaterial, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateMaterialTitle = `-- name: UpdateMaterialTitle :execrows
UPDATE materials m
SET title = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE m.id = $2
  AND EXISTS (
      SELECT 1 
      FROM collections c 
      WHERE c.id = m.collection_id 
        AND c.user_id = $3
  )
`

type UpdateMaterialTitleParams struct {
	Title  string    `json:"title"`
	ID     uuid.UUID `json:"id"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateMaterialTitle(ctx context.Context, arg UpdateMaterialTitleParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateMaterialTitle, arg.Title, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
